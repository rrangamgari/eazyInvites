/*! WOW wow.js - v1.3.0 - 2016-10-04
* https://wowjs.uk
* Copyright (c) 2016 Thomas Grainger; Licensed MIT */!(function (a, b) { if (typeof define === 'function' && define.amd)define(['module', 'exports'], b); else if (typeof exports !== 'undefined')b(module, exports); else { const c = { exports: {} }; b(c, c.exports), a.WOW = c.exports; } }(this, (a, b) => {
  function c(a, b) { if (!(a instanceof b)) throw new TypeError('Cannot call a class as a function'); } function d(a, b) { return b.indexOf(a) >= 0; } function e(a, b) { for (const c in b) if (a[c] == null) { const d = b[c]; a[c] = d; } return a; } function f(a) { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(a); } function g(a) { const b = arguments.length <= 1 || void 0 === arguments[1] ? !1 : arguments[1]; const c = arguments.length <= 2 || void 0 === arguments[2] ? !1 : arguments[2]; const d = arguments.length <= 3 || void 0 === arguments[3] ? null : arguments[3]; let e = void 0; return document.createEvent != null ? (e = document.createEvent('CustomEvent'), e.initCustomEvent(a, b, c, d)) : document.createEventObject != null ? (e = document.createEventObject(), e.eventType = a) : e.eventName = a, e; } function h(a, b) { a.dispatchEvent != null ? a.dispatchEvent(b) : b in (a != null) ? a[b]() : `on${b}` in (a != null) && a[`on${b}`](); } function i(a, b, c) { a.addEventListener != null ? a.addEventListener(b, c, !1) : a.attachEvent != null ? a.attachEvent(`on${b}`, c) : a[b] = c; } function j(a, b, c) { a.removeEventListener != null ? a.removeEventListener(b, c, !1) : a.detachEvent != null ? a.detachEvent(`on${b}`, c) : delete a[b]; } function k() { return 'innerHeight' in window ? window.innerHeight : document.documentElement.clientHeight; }Object.defineProperty(b, '__esModule', { value: !0 }); let l; let m; const n = (function () { function a(a, b) { for (let c = 0; c < b.length; c++) { const d = b[c]; d.enumerable = d.enumerable || !1, d.configurable = !0, 'value' in d && (d.writable = !0), Object.defineProperty(a, d.key, d); } } return function (b, c, d) { return c && a(b.prototype, c), d && a(b, d), b; }; }()); const o = window.WeakMap || window.MozWeakMap || (function () { function a() { c(this, a), this.keys = [], this.values = []; } return n(a, [{ key: 'get', value(a) { for (let b = 0; b < this.keys.length; b++) { const c = this.keys[b]; if (c === a) return this.values[b]; } } }, { key: 'set', value(a, b) { for (let c = 0; c < this.keys.length; c++) { const d = this.keys[c]; if (d === a) return this.values[c] = b, this; } return this.keys.push(a), this.values.push(b), this; } }]), a; }()); const p = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver || (m = l = (function () { function a() { c(this, a), typeof console !== 'undefined' && console !== null && (console.warn('MutationObserver is not supported by your browser.'), console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.')); } return n(a, [{ key: 'observe', value() {} }]), a; }()), l.notSupported = !0, m); const q = window.getComputedStyle || function (a) { const b = /(\-([a-z]){1})/g; return { getPropertyValue(c) { c === 'float' && (c = 'styleFloat'), b.test(c) && c.replace(b, (a, b) => b.toUpperCase()); const d = a.currentStyle; return (d != null ? d[c] : void 0) || null; } }; }; const r = (function () {
    function a() {
      const b = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0]; c(this, a), this.defaults = {
        boxClass: 'wow', animateClass: 'animated', offset: 0, mobile: !0, live: !0, callback: null, scrollContainer: null, resetAnimation: !0,
      }, this.animate = (function () { return 'requestAnimationFrame' in window ? function (a) { return window.requestAnimationFrame(a); } : function (a) { return a(); }; }()), this.vendors = ['moz', 'webkit'], this.start = this.start.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.scrollHandler = this.scrollHandler.bind(this), this.scrollCallback = this.scrollCallback.bind(this), this.scrolled = !0, this.config = e(b, this.defaults), b.scrollContainer != null && (this.config.scrollContainer = document.querySelector(b.scrollContainer)), this.animationNameCache = new o(), this.wowEvent = g(this.config.boxClass);
    } return n(a, [{ key: 'init', value() { this.element = window.document.documentElement, d(document.readyState, ['interactive', 'complete']) ? this.start() : i(document, 'DOMContentLoaded', this.start), this.finished = []; } }, { key: 'start', value() { const a = this; if (this.stopped = !1, this.boxes = [].slice.call(this.element.querySelectorAll(`.${this.config.boxClass}`)), this.all = this.boxes.slice(0), this.boxes.length) if (this.disabled()) this.resetStyle(); else for (let b = 0; b < this.boxes.length; b++) { const c = this.boxes[b]; this.applyStyle(c, !0); } if (this.disabled() || (i(this.config.scrollContainer || window, 'scroll', this.scrollHandler), i(window, 'resize', this.scrollHandler), this.interval = setInterval(this.scrollCallback, 50)), this.config.live) { const d = new p(((b) => { for (let c = 0; c < b.length; c++) for (let d = b[c], e = 0; e < d.addedNodes.length; e++) { const f = d.addedNodes[e]; a.doSync(f); } })); d.observe(document.body, { childList: !0, subtree: !0 }); } } }, { key: 'stop', value() { this.stopped = !0, j(this.config.scrollContainer || window, 'scroll', this.scrollHandler), j(window, 'resize', this.scrollHandler), this.interval != null && clearInterval(this.interval); } }, { key: 'sync', value() { p.notSupported && this.doSync(this.element); } }, { key: 'doSync', value(a) { if (typeof a !== 'undefined' && a !== null || (a = this.element), a.nodeType === 1) { a = a.parentNode || a; for (let b = a.querySelectorAll(`.${this.config.boxClass}`), c = 0; c < b.length; c++) { const e = b[c]; d(e, this.all) || (this.boxes.push(e), this.all.push(e), this.stopped || this.disabled() ? this.resetStyle() : this.applyStyle(e, !0), this.scrolled = !0); } } } }, { key: 'show', value(a) { return this.applyStyle(a), a.className = `${a.className} ${this.config.animateClass}`, this.config.callback != null && this.config.callback(a), h(a, this.wowEvent), this.config.resetAnimation && (i(a, 'animationend', this.resetAnimation), i(a, 'oanimationend', this.resetAnimation), i(a, 'webkitAnimationEnd', this.resetAnimation), i(a, 'MSAnimationEnd', this.resetAnimation)), a; } }, { key: 'applyStyle', value(a, b) { const c = this; const d = a.getAttribute('data-wow-duration'); const e = a.getAttribute('data-wow-delay'); const f = a.getAttribute('data-wow-iteration'); return this.animate(() => c.customStyle(a, b, d, e, f)); } }, { key: 'resetStyle', value() { for (let a = 0; a < this.boxes.length; a++) { const b = this.boxes[a]; b.style.visibility = 'visible'; } } }, { key: 'resetAnimation', value(a) { if (a.type.toLowerCase().indexOf('animationend') >= 0) { const b = a.target || a.srcElement; b.className = b.className.replace(this.config.animateClass, '').trim(); } } }, { key: 'customStyle', value(a, b, c, d, e) { return b && this.cacheAnimationName(a), a.style.visibility = b ? 'hidden' : 'visible', c && this.vendorSet(a.style, { animationDuration: c }), d && this.vendorSet(a.style, { animationDelay: d }), e && this.vendorSet(a.style, { animationIterationCount: e }), this.vendorSet(a.style, { animationName: b ? 'none' : this.cachedAnimationName(a) }), a; } }, { key: 'vendorSet', value(a, b) { for (const c in b) if (b.hasOwnProperty(c)) { const d = b[c]; a[`${c}`] = d; for (let e = 0; e < this.vendors.length; e++) { const f = this.vendors[e]; a[`${f}${c.charAt(0).toUpperCase()}${c.substr(1)}`] = d; } } } }, { key: 'vendorCSS', value(a, b) { for (var c = q(a), d = c.getPropertyCSSValue(b), e = 0; e < this.vendors.length; e++) { const f = this.vendors[e]; d = d || c.getPropertyCSSValue(`-${f}-${b}`); } return d; } }, { key: 'animationName', value(a) { let b = void 0; try { b = this.vendorCSS(a, 'animation-name').cssText; } catch (c) { b = q(a).getPropertyValue('animation-name'); } return b === 'none' ? '' : b; } }, { key: 'cacheAnimationName', value(a) { return this.animationNameCache.set(a, this.animationName(a)); } }, { key: 'cachedAnimationName', value(a) { return this.animationNameCache.get(a); } }, { key: 'scrollHandler', value() { this.scrolled = !0; } }, { key: 'scrollCallback', value() { if (this.scrolled) { this.scrolled = !1; for (var a = [], b = 0; b < this.boxes.length; b++) { const c = this.boxes[b]; if (c) { if (this.isVisible(c)) { this.show(c); continue; }a.push(c); } } this.boxes = a, this.boxes.length || this.config.live || this.stop(); } } }, { key: 'offsetTop', value(a) { for (;void 0 === a.offsetTop;)a = a.parentNode; for (var b = a.offsetTop; a.offsetParent;)a = a.offsetParent, b += a.offsetTop; return b; } }, { key: 'isVisible', value(a) { const b = a.getAttribute('data-wow-offset') || this.config.offset; const c = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset; const d = c + Math.min(this.element.clientHeight, k()) - b; const e = this.offsetTop(a); const f = e + a.clientHeight; return d >= e && f >= c; } }, { key: 'disabled', value() { return !this.config.mobile && f(navigator.userAgent); } }]), a;
  }()); b.default = r, a.exports = b.default;
}));
