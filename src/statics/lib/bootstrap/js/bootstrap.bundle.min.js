/*!
  * Bootstrap v4.2.1 (https://getbootstrap.com/)
  * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? e(exports, require('jquery')) : typeof define === 'function' && define.amd ? define(['exports', 'jquery'], e) : e(t.bootstrap = {}, t.jQuery); }(this, (t, p) => {
  function i(t, e) { for (let n = 0; n < e.length; n++) { const i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i); } } function s(t, e, n) { return e && i(t.prototype, e), n && i(t, n), t; } function l(o) {
    for (let t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {}; let e = Object.keys(r); typeof Object.getOwnPropertySymbols === 'function' && (e = e.concat(Object.getOwnPropertySymbols(r).filter((t) => Object.getOwnPropertyDescriptor(r, t).enumerable))), e.forEach((t) => {
        let e; let n; let i; e = o, i = r[n = t], n in e ? Object.defineProperty(e, n, {
          value: i, enumerable: !0, configurable: !0, writable: !0,
        }) : e[n] = i;
      });
    } return o;
  }p = p && p.hasOwnProperty('default') ? p.default : p; const e = 'transitionend'; function n(t) { const e = this; let n = !1; return p(this).one(m.TRANSITION_END, () => { n = !0; }), setTimeout(() => { n || m.triggerTransitionEnd(e); }, t), this; } var m = {
    TRANSITION_END: 'bsTransitionEnd', getUID(t) { for (;t += ~~(1e6 * Math.random()), document.getElementById(t););return t; }, getSelectorFromElement(t) { let e = t.getAttribute('data-target'); if (!e || e === '#') { const n = t.getAttribute('href'); e = n && n !== '#' ? n.trim() : ''; } return e && document.querySelector(e) ? e : null; }, getTransitionDurationFromElement(t) { if (!t) return 0; let e = p(t).css('transition-duration'); let n = p(t).css('transition-delay'); const i = parseFloat(e); const o = parseFloat(n); return i || o ? (e = e.split(',')[0], n = n.split(',')[0], 1e3 * (parseFloat(e) + parseFloat(n))) : 0; }, reflow(t) { return t.offsetHeight; }, triggerTransitionEnd(t) { p(t).trigger(e); }, supportsTransitionEnd() { return Boolean(e); }, isElement(t) { return (t[0] || t).nodeType; }, typeCheckConfig(t, e, n) { for (const i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { const o = n[i]; const r = e[i]; const s = r && m.isElement(r) ? 'element' : (a = r, {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase()); if (!new RegExp(o).test(s)) throw new Error(`${t.toUpperCase()}: Option "${i}" provided type "${s}" but expected type "${o}".`); } let a; }, findShadowRoot(t) { if (!document.documentElement.attachShadow) return null; if (typeof t.getRootNode !== 'function') return t instanceof ShadowRoot ? t : t.parentNode ? m.findShadowRoot(t.parentNode) : null; const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null; },
  }; p.fn.emulateTransitionEnd = n, p.event.special[m.TRANSITION_END] = { bindType: e, delegateType: e, handle(t) { if (p(t.target).is(this)) return t.handleObj.handler.apply(this, arguments); } }; const o = 'alert'; const r = 'bs.alert'; const a = `.${r}`; const c = p.fn[o]; const h = { CLOSE: `close${a}`, CLOSED: `closed${a}`, CLICK_DATA_API: `click${a}.data-api` }; const u = 'alert'; const f = 'fade'; const d = 'show'; const g = (function () { function i(t) { this._element = t; } const t = i.prototype; return t.close = function (t) { let e = this._element; t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e); }, t.dispose = function () { p.removeData(this._element, r), this._element = null; }, t._getRootElement = function (t) { const e = m.getSelectorFromElement(t); let n = !1; return e && (n = document.querySelector(e)), n || (n = p(t).closest(`.${u}`)[0]), n; }, t._triggerCloseEvent = function (t) { const e = p.Event(h.CLOSE); return p(t).trigger(e), e; }, t._removeElement = function (e) { const n = this; if (p(e).removeClass(d), p(e).hasClass(f)) { const t = m.getTransitionDurationFromElement(e); p(e).one(m.TRANSITION_END, (t) => n._destroyElement(e, t)).emulateTransitionEnd(t); } else this._destroyElement(e); }, t._destroyElement = function (t) { p(t).detach().trigger(h.CLOSED).remove(); }, i._jQueryInterface = function (n) { return this.each(function () { const t = p(this); let e = t.data(r); e || (e = new i(this), t.data(r, e)), n === 'close' && e[n](this); }); }, i._handleDismiss = function (e) { return function (t) { t && t.preventDefault(), e.close(this); }; }, s(i, null, [{ key: 'VERSION', get() { return '4.2.1'; } }]), i; }()); p(document).on(h.CLICK_DATA_API, '[data-dismiss="alert"]', g._handleDismiss(new g())), p.fn[o] = g._jQueryInterface, p.fn[o].Constructor = g, p.fn[o].noConflict = function () { return p.fn[o] = c, g._jQueryInterface; }; const _ = 'button'; const v = 'bs.button'; const y = `.${v}`; const E = '.data-api'; const b = p.fn[_]; const w = 'active'; const T = 'btn'; const C = 'focus'; const S = '[data-toggle^="button"]'; const D = '[data-toggle="buttons"]'; const I = 'input:not([type="hidden"])'; const A = '.active'; const O = '.btn'; const N = { CLICK_DATA_API: `click${y}${E}`, FOCUS_BLUR_DATA_API: `focus${y}${E} blur${y}${E}` }; const k = (function () { function n(t) { this._element = t; } const t = n.prototype; return t.toggle = function () { let t = !0; let e = !0; const n = p(this._element).closest(D)[0]; if (n) { const i = this._element.querySelector(I); if (i) { if (i.type === 'radio') if (i.checked && this._element.classList.contains(w))t = !1; else { const o = n.querySelector(A); o && p(o).removeClass(w); } if (t) { if (i.hasAttribute('disabled') || n.hasAttribute('disabled') || i.classList.contains('disabled') || n.classList.contains('disabled')) return; i.checked = !this._element.classList.contains(w), p(i).trigger('change'); }i.focus(), e = !1; } }e && this._element.setAttribute('aria-pressed', !this._element.classList.contains(w)), t && p(this._element).toggleClass(w); }, t.dispose = function () { p.removeData(this._element, v), this._element = null; }, n._jQueryInterface = function (e) { return this.each(function () { let t = p(this).data(v); t || (t = new n(this), p(this).data(v, t)), e === 'toggle' && t[e](); }); }, s(n, null, [{ key: 'VERSION', get() { return '4.2.1'; } }]), n; }()); p(document).on(N.CLICK_DATA_API, S, (t) => { t.preventDefault(); let e = t.target; p(e).hasClass(T) || (e = p(e).closest(O)), k._jQueryInterface.call(p(e), 'toggle'); }).on(N.FOCUS_BLUR_DATA_API, S, (t) => { const e = p(t.target).closest(O)[0]; p(e).toggleClass(C, /^focus(in)?$/.test(t.type)); }), p.fn[_] = k._jQueryInterface, p.fn[_].Constructor = k, p.fn[_].noConflict = function () { return p.fn[_] = b, k._jQueryInterface; }; const L = 'carousel'; const P = 'bs.carousel'; const x = `.${P}`; const H = '.data-api'; const j = p.fn[L]; const R = {
    interval: 5e3, keyboard: !0, slide: !1, pause: 'hover', wrap: !0, touch: !0,
  }; const F = {
    interval: '(number|boolean)', keyboard: 'boolean', slide: '(boolean|string)', pause: '(string|boolean)', wrap: 'boolean', touch: 'boolean',
  }; const M = 'next'; const W = 'prev'; const U = 'left'; const B = 'right'; const q = {
    SLIDE: `slide${x}`, SLID: `slid${x}`, KEYDOWN: `keydown${x}`, MOUSEENTER: `mouseenter${x}`, MOUSELEAVE: `mouseleave${x}`, TOUCHSTART: `touchstart${x}`, TOUCHMOVE: `touchmove${x}`, TOUCHEND: `touchend${x}`, POINTERDOWN: `pointerdown${x}`, POINTERUP: `pointerup${x}`, DRAG_START: `dragstart${x}`, LOAD_DATA_API: `load${x}${H}`, CLICK_DATA_API: `click${x}${H}`,
  }; const K = 'carousel'; const Q = 'active'; const Y = 'slide'; const V = 'carousel-item-right'; const X = 'carousel-item-left'; const z = 'carousel-item-next'; const G = 'carousel-item-prev'; const J = 'pointer-event'; const Z = '.active'; const $ = '.active.carousel-item'; const tt = '.carousel-item'; const et = '.carousel-item img'; const nt = '.carousel-item-next, .carousel-item-prev'; const it = '.carousel-indicators'; const ot = '[data-slide], [data-slide-to]'; const rt = '[data-ride="carousel"]'; const st = { TOUCH: 'touch', PEN: 'pen' }; const at = (function () {
    function r(t, e) { this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector(it), this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners(); } const t = r.prototype; return t.next = function () { this._isSliding || this._slide(M); }, t.nextWhenVisible = function () { !document.hidden && p(this._element).is(':visible') && p(this._element).css('visibility') !== 'hidden' && this.next(); }, t.prev = function () { this._isSliding || this._slide(W); }, t.pause = function (t) { t || (this._isPaused = !0), this._element.querySelector(nt) && (m.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null; }, t.cycle = function (t) { t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)); }, t.to = function (t) { const e = this; this._activeElement = this._element.querySelector($); const n = this._getItemIndex(this._activeElement); if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding)p(this._element).one(q.SLID, () => e.to(t)); else { if (n === t) return this.pause(), void this.cycle(); const i = n < t ? M : W; this._slide(i, this._items[t]); } }, t.dispose = function () { p(this._element).off(x), p.removeData(this._element, P), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null; }, t._getConfig = function (t) { return t = l({}, R, t), m.typeCheckConfig(L, t, F), t; }, t._handleSwipe = function () { const t = Math.abs(this.touchDeltaX); if (!(t <= 40)) { const e = t / this.touchDeltaX; e > 0 && this.prev(), e < 0 && this.next(); } }, t._addEventListeners = function () { const e = this; this._config.keyboard && p(this._element).on(q.KEYDOWN, (t) => e._keydown(t)), this._config.pause === 'hover' && p(this._element).on(q.MOUSEENTER, (t) => e.pause(t)).on(q.MOUSELEAVE, (t) => e.cycle(t)), this._addTouchEventListeners(); }, t._addTouchEventListeners = function () { const n = this; if (this._touchSupported) { const e = function (t) { n._pointerEvent && st[t.originalEvent.pointerType.toUpperCase()] ? n.touchStartX = t.originalEvent.clientX : n._pointerEvent || (n.touchStartX = t.originalEvent.touches[0].clientX); }; const i = function (t) { n._pointerEvent && st[t.originalEvent.pointerType.toUpperCase()] && (n.touchDeltaX = t.originalEvent.clientX - n.touchStartX), n._handleSwipe(), n._config.pause === 'hover' && (n.pause(), n.touchTimeout && clearTimeout(n.touchTimeout), n.touchTimeout = setTimeout((t) => n.cycle(t), 500 + n._config.interval)); }; p(this._element.querySelectorAll(et)).on(q.DRAG_START, (t) => t.preventDefault()), this._pointerEvent ? (p(this._element).on(q.POINTERDOWN, (t) => e(t)), p(this._element).on(q.POINTERUP, (t) => i(t)), this._element.classList.add(J)) : (p(this._element).on(q.TOUCHSTART, (t) => e(t)), p(this._element).on(q.TOUCHMOVE, (t) => { let e; (e = t).originalEvent.touches && e.originalEvent.touches.length > 1 ? n.touchDeltaX = 0 : n.touchDeltaX = e.originalEvent.touches[0].clientX - n.touchStartX; }), p(this._element).on(q.TOUCHEND, (t) => i(t))); } }, t._keydown = function (t) { if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) { case 37: t.preventDefault(), this.prev(); break; case 39: t.preventDefault(), this.next(); } }, t._getItemIndex = function (t) { return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(tt)) : [], this._items.indexOf(t); }, t._getItemByDirection = function (t, e) { const n = t === M; const i = t === W; const o = this._getItemIndex(e); const r = this._items.length - 1; if ((i && o === 0 || n && o === r) && !this._config.wrap) return e; const s = (o + (t === W ? -1 : 1)) % this._items.length; return s === -1 ? this._items[this._items.length - 1] : this._items[s]; }, t._triggerSlideEvent = function (t, e) {
      const n = this._getItemIndex(t); const i = this._getItemIndex(this._element.querySelector($)); const o = p.Event(q.SLIDE, {
        relatedTarget: t, direction: e, from: i, to: n,
      }); return p(this._element).trigger(o), o;
    }, t._setActiveIndicatorElement = function (t) { if (this._indicatorsElement) { const e = [].slice.call(this._indicatorsElement.querySelectorAll(Z)); p(e).removeClass(Q); const n = this._indicatorsElement.children[this._getItemIndex(t)]; n && p(n).addClass(Q); } }, t._slide = function (t, e) {
      let n; let i; let o; const r = this; const s = this._element.querySelector($); const a = this._getItemIndex(s); const l = e || s && this._getItemByDirection(t, s); const c = this._getItemIndex(l); const h = Boolean(this._interval); if (o = t === M ? (n = X, i = z, U) : (n = V, i = G, B), l && p(l).hasClass(Q)) this._isSliding = !1; else if (!this._triggerSlideEvent(l, o).isDefaultPrevented() && s && l) {
        this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(l); const u = p.Event(q.SLID, {
          relatedTarget: l, direction: o, from: a, to: c,
        }); if (p(this._element).hasClass(Y)) { p(l).addClass(i), m.reflow(l), p(s).addClass(n), p(l).addClass(n); const f = parseInt(l.getAttribute('data-interval'), 10); this._config.interval = f ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, f) : this._config.defaultInterval || this._config.interval; const d = m.getTransitionDurationFromElement(s); p(s).one(m.TRANSITION_END, () => { p(l).removeClass(`${n} ${i}`).addClass(Q), p(s).removeClass(`${Q} ${i} ${n}`), r._isSliding = !1, setTimeout(() => p(r._element).trigger(u), 0); }).emulateTransitionEnd(d); } else p(s).removeClass(Q), p(l).addClass(Q), this._isSliding = !1, p(this._element).trigger(u); h && this.cycle();
      }
    }, r._jQueryInterface = function (i) { return this.each(function () { let t = p(this).data(P); let e = l({}, R, p(this).data()); typeof i === 'object' && (e = l({}, e, i)); const n = typeof i === 'string' ? i : e.slide; if (t || (t = new r(this, e), p(this).data(P, t)), typeof i === 'number')t.to(i); else if (typeof n === 'string') { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n](); } else e.interval && (t.pause(), t.cycle()); }); }, r._dataApiClickHandler = function (t) { const e = m.getSelectorFromElement(this); if (e) { const n = p(e)[0]; if (n && p(n).hasClass(K)) { const i = l({}, p(n).data(), p(this).data()); const o = this.getAttribute('data-slide-to'); o && (i.interval = !1), r._jQueryInterface.call(p(n), i), o && p(n).data(P).to(o), t.preventDefault(); } } }, s(r, null, [{ key: 'VERSION', get() { return '4.2.1'; } }, { key: 'Default', get() { return R; } }]), r;
  }()); p(document).on(q.CLICK_DATA_API, ot, at._dataApiClickHandler), p(window).on(q.LOAD_DATA_API, () => { for (let t = [].slice.call(document.querySelectorAll(rt)), e = 0, n = t.length; e < n; e++) { const i = p(t[e]); at._jQueryInterface.call(i, i.data()); } }), p.fn[L] = at._jQueryInterface, p.fn[L].Constructor = at, p.fn[L].noConflict = function () { return p.fn[L] = j, at._jQueryInterface; }; const lt = 'collapse'; const ct = 'bs.collapse'; const ht = `.${ct}`; const ut = p.fn[lt]; const ft = { toggle: !0, parent: '' }; const dt = { toggle: 'boolean', parent: '(string|element)' }; const pt = {
    SHOW: `show${ht}`, SHOWN: `shown${ht}`, HIDE: `hide${ht}`, HIDDEN: `hidden${ht}`, CLICK_DATA_API: `click${ht}.data-api`,
  }; const mt = 'show'; const gt = 'collapse'; const _t = 'collapsing'; const vt = 'collapsed'; const yt = 'width'; const Et = 'height'; const bt = '.show, .collapsing'; const wt = '[data-toggle="collapse"]'; const Tt = (function () { function a(e, t) { this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = [].slice.call(document.querySelectorAll(`[data-toggle="collapse"][href="#${e.id}"],[data-toggle="collapse"][data-target="#${e.id}"]`)); for (let n = [].slice.call(document.querySelectorAll(wt)), i = 0, o = n.length; i < o; i++) { const r = n[i]; const s = m.getSelectorFromElement(r); const a = [].slice.call(document.querySelectorAll(s)).filter((t) => t === e); s !== null && a.length > 0 && (this._selector = s, this._triggerArray.push(r)); } this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle(); } const t = a.prototype; return t.toggle = function () { p(this._element).hasClass(mt) ? this.hide() : this.show(); }, t.show = function () { let t; let e; const n = this; if (!this._isTransitioning && !p(this._element).hasClass(mt) && (this._parent && (t = [].slice.call(this._parent.querySelectorAll(bt)).filter((t) => (typeof n._config.parent === 'string' ? t.getAttribute('data-parent') === n._config.parent : t.classList.contains(gt)))).length === 0 && (t = null), !(t && (e = p(t).not(this._selector).data(ct)) && e._isTransitioning))) { const i = p.Event(pt.SHOW); if (p(this._element).trigger(i), !i.isDefaultPrevented()) { t && (a._jQueryInterface.call(p(t).not(this._selector), 'hide'), e || p(t).data(ct, null)); const o = this._getDimension(); p(this._element).removeClass(gt).addClass(_t), this._element.style[o] = 0, this._triggerArray.length && p(this._triggerArray).removeClass(vt).attr('aria-expanded', !0), this.setTransitioning(!0); const r = `scroll${o[0].toUpperCase() + o.slice(1)}`; const s = m.getTransitionDurationFromElement(this._element); p(this._element).one(m.TRANSITION_END, () => { p(n._element).removeClass(_t).addClass(gt).addClass(mt), n._element.style[o] = '', n.setTransitioning(!1), p(n._element).trigger(pt.SHOWN); }).emulateTransitionEnd(s), this._element.style[o] = `${this._element[r]}px`; } } }, t.hide = function () { const t = this; if (!this._isTransitioning && p(this._element).hasClass(mt)) { const e = p.Event(pt.HIDE); if (p(this._element).trigger(e), !e.isDefaultPrevented()) { const n = this._getDimension(); this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`, m.reflow(this._element), p(this._element).addClass(_t).removeClass(gt).removeClass(mt); const i = this._triggerArray.length; if (i > 0) for (let o = 0; o < i; o++) { const r = this._triggerArray[o]; const s = m.getSelectorFromElement(r); if (s !== null)p([].slice.call(document.querySelectorAll(s))).hasClass(mt) || p(r).addClass(vt).attr('aria-expanded', !1); } this.setTransitioning(!0); this._element.style[n] = ''; const a = m.getTransitionDurationFromElement(this._element); p(this._element).one(m.TRANSITION_END, () => { t.setTransitioning(!1), p(t._element).removeClass(_t).addClass(gt).trigger(pt.HIDDEN); }).emulateTransitionEnd(a); } } }, t.setTransitioning = function (t) { this._isTransitioning = t; }, t.dispose = function () { p.removeData(this._element, ct), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null; }, t._getConfig = function (t) { return (t = l({}, ft, t)).toggle = Boolean(t.toggle), m.typeCheckConfig(lt, t, dt), t; }, t._getDimension = function () { return p(this._element).hasClass(yt) ? yt : Et; }, t._getParent = function () { let t; const n = this; m.isElement(this._config.parent) ? (t = this._config.parent, typeof this._config.parent.jquery !== 'undefined' && (t = this._config.parent[0])) : t = document.querySelector(this._config.parent); const e = `[data-toggle="collapse"][data-parent="${this._config.parent}"]`; const i = [].slice.call(t.querySelectorAll(e)); return p(i).each((t, e) => { n._addAriaAndCollapsedClass(a._getTargetFromElement(e), [e]); }), t; }, t._addAriaAndCollapsedClass = function (t, e) { const n = p(t).hasClass(mt); e.length && p(e).toggleClass(vt, !n).attr('aria-expanded', n); }, a._getTargetFromElement = function (t) { const e = m.getSelectorFromElement(t); return e ? document.querySelector(e) : null; }, a._jQueryInterface = function (i) { return this.each(function () { const t = p(this); let e = t.data(ct); const n = l({}, ft, t.data(), typeof i === 'object' && i ? i : {}); if (!e && n.toggle && /show|hide/.test(i) && (n.toggle = !1), e || (e = new a(this, n), t.data(ct, e)), typeof i === 'string') { if (typeof e[i] === 'undefined') throw new TypeError(`No method named "${i}"`); e[i](); } }); }, s(a, null, [{ key: 'VERSION', get() { return '4.2.1'; } }, { key: 'Default', get() { return ft; } }]), a; }()); p(document).on(pt.CLICK_DATA_API, wt, function (t) { t.currentTarget.tagName === 'A' && t.preventDefault(); const n = p(this); const e = m.getSelectorFromElement(this); const i = [].slice.call(document.querySelectorAll(e)); p(i).each(function () { const t = p(this); const e = t.data(ct) ? 'toggle' : n.data(); Tt._jQueryInterface.call(t, e); }); }), p.fn[lt] = Tt._jQueryInterface, p.fn[lt].Constructor = Tt, p.fn[lt].noConflict = function () { return p.fn[lt] = ut, Tt._jQueryInterface; }; for (var Ct = typeof window !== 'undefined' && typeof document !== 'undefined', St = ['Edge', 'Trident', 'Firefox'], Dt = 0, It = 0; It < St.length; It += 1) if (Ct && navigator.userAgent.indexOf(St[It]) >= 0) { Dt = 1; break; } const At = Ct && window.Promise ? function (t) { let e = !1; return function () { e || (e = !0, window.Promise.resolve().then(() => { e = !1, t(); })); }; } : function (t) { let e = !1; return function () { e || (e = !0, setTimeout(() => { e = !1, t(); }, Dt)); }; }; function Ot(t) { return t && {}.toString.call(t) === '[object Function]'; } function Nt(t, e) { if (t.nodeType !== 1) return []; const n = t.ownerDocument.defaultView.getComputedStyle(t, null); return e ? n[e] : n; } function kt(t) { return t.nodeName === 'HTML' ? t : t.parentNode || t.host; } function Lt(t) { if (!t) return document.body; switch (t.nodeName) { case 'HTML': case 'BODY': return t.ownerDocument.body; case '#document': return t.body; } const e = Nt(t); const n = e.overflow; const i = e.overflowX; const o = e.overflowY; return /(auto|scroll|overlay)/.test(n + o + i) ? t : Lt(kt(t)); } const Pt = Ct && !(!window.MSInputMethodContext || !document.documentMode); const xt = Ct && /MSIE 10/.test(navigator.userAgent); function Ht(t) { return t === 11 ? Pt : t === 10 ? xt : Pt || xt; } function jt(t) { if (!t) return document.documentElement; for (var e = Ht(10) ? document.body : null, n = t.offsetParent || null; n === e && t.nextElementSibling;)n = (t = t.nextElementSibling).offsetParent; const i = n && n.nodeName; return i && i !== 'BODY' && i !== 'HTML' ? ['TH', 'TD', 'TABLE'].indexOf(n.nodeName) !== -1 && Nt(n, 'position') === 'static' ? jt(n) : n : t ? t.ownerDocument.documentElement : document.documentElement; } function Rt(t) { return t.parentNode !== null ? Rt(t.parentNode) : t; } function Ft(t, e) { if (!(t && t.nodeType && e && e.nodeType)) return document.documentElement; const n = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING; const i = n ? t : e; const o = n ? e : t; const r = document.createRange(); r.setStart(i, 0), r.setEnd(o, 0); let s; let a; const l = r.commonAncestorContainer; if (t !== l && e !== l || i.contains(o)) return (a = (s = l).nodeName) === 'BODY' || a !== 'HTML' && jt(s.firstElementChild) !== s ? jt(l) : l; const c = Rt(t); return c.host ? Ft(c.host, e) : Ft(t, Rt(e).host); } function Mt(t) {
    const e = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'top') === 'top' ? 'scrollTop' : 'scrollLeft'; const
      n = t.nodeName; if (n !== 'BODY' && n !== 'HTML') return t[e]; const i = t.ownerDocument.documentElement; return (t.ownerDocument.scrollingElement || i)[e];
  } function Wt(t, e) {
    const n = e === 'x' ? 'Left' : 'Top'; const
      i = n === 'Left' ? 'Right' : 'Bottom'; return parseFloat(t[`border${n}Width`], 10) + parseFloat(t[`border${i}Width`], 10);
  } function Ut(t, e, n, i) { return Math.max(e[`offset${t}`], e[`scroll${t}`], n[`client${t}`], n[`offset${t}`], n[`scroll${t}`], Ht(10) ? parseInt(n[`offset${t}`]) + parseInt(i[`margin${t === 'Height' ? 'Top' : 'Left'}`]) + parseInt(i[`margin${t === 'Height' ? 'Bottom' : 'Right'}`]) : 0); } function Bt(t) { const e = t.body; const n = t.documentElement; const i = Ht(10) && getComputedStyle(n); return { height: Ut('Height', e, n, i), width: Ut('Width', e, n, i) }; } const qt = (function () { function i(t, e) { for (let n = 0; n < e.length; n++) { const i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i); } } return function (t, e, n) { return e && i(t.prototype, e), n && i(t, n), t; }; }()); const Kt = function (t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : t[e] = n, t;
  }; const Qt = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); } return t; }; function Yt(t) { return { ...t, right: t.left + t.width, bottom: t.top + t.height }; } function Vt(t) {
    let e = {}; try { if (Ht(10)) { e = t.getBoundingClientRect(); const n = Mt(t, 'top'); const i = Mt(t, 'left'); e.top += n, e.left += i, e.bottom += n, e.right += i; } else e = t.getBoundingClientRect(); } catch (t) {} const o = {
      left: e.left, top: e.top, width: e.right - e.left, height: e.bottom - e.top,
    }; const r = t.nodeName === 'HTML' ? Bt(t.ownerDocument) : {}; const s = r.width || t.clientWidth || o.right - o.left; const a = r.height || t.clientHeight || o.bottom - o.top; let l = t.offsetWidth - s; let c = t.offsetHeight - a; if (l || c) { const h = Nt(t); l -= Wt(h, 'x'), c -= Wt(h, 'y'), o.width -= l, o.height -= c; } return Yt(o);
  } function Xt(t, e) {
    const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = Ht(10); const o = e.nodeName === 'HTML'; const r = Vt(t); const s = Vt(e); const a = Lt(t); const l = Nt(e); const c = parseFloat(l.borderTopWidth, 10); const h = parseFloat(l.borderLeftWidth, 10); n && o && (s.top = Math.max(s.top, 0), s.left = Math.max(s.left, 0)); let u = Yt({
      top: r.top - s.top - c, left: r.left - s.left - h, width: r.width, height: r.height,
    }); if (u.marginTop = 0, u.marginLeft = 0, !i && o) { const f = parseFloat(l.marginTop, 10); const d = parseFloat(l.marginLeft, 10); u.top -= c - f, u.bottom -= c - f, u.left -= h - d, u.right -= h - d, u.marginTop = f, u.marginLeft = d; } return (i && !n ? e.contains(a) : e === a && a.nodeName !== 'BODY') && (u = (function (t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = Mt(e, 'top'); const o = Mt(e, 'left'); const r = n ? -1 : 1; return t.top += i * r, t.bottom += i * r, t.left += o * r, t.right += o * r, t; }(u, e))), u;
  } function zt(t) { if (!t || !t.parentElement || Ht()) return document.documentElement; for (var e = t.parentElement; e && Nt(e, 'transform') === 'none';)e = e.parentElement; return e || document.documentElement; } function Gt(t, e, n, i) {
    const o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let r = { top: 0, left: 0 }; const s = o ? zt(t) : Ft(t, e); if (i === 'viewport') {
      r = (function (t) {
        const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = t.ownerDocument.documentElement; const i = Xt(t, n); const o = Math.max(n.clientWidth, window.innerWidth || 0); const r = Math.max(n.clientHeight, window.innerHeight || 0); const s = e ? 0 : Mt(n); const a = e ? 0 : Mt(n, 'left'); return Yt({
          top: s - i.top + i.marginTop, left: a - i.left + i.marginLeft, width: o, height: r,
        });
      }(s, o));
    } else { let a = void 0; i === 'scrollParent' ? (a = Lt(kt(e))).nodeName === 'BODY' && (a = t.ownerDocument.documentElement) : a = i === 'window' ? t.ownerDocument.documentElement : i; const l = Xt(a, s, o); if (a.nodeName !== 'HTML' || (function t(e) { const n = e.nodeName; return n !== 'BODY' && n !== 'HTML' && (Nt(e, 'position') === 'fixed' || t(kt(e))); }(s)))r = l; else { const c = Bt(t.ownerDocument); const h = c.height; const u = c.width; r.top += l.top - l.marginTop, r.bottom = h + l.top, r.left += l.left - l.marginLeft, r.right = u + l.left; } } const f = typeof (n = n || 0) === 'number'; return r.left += f ? n : n.left || 0, r.top += f ? n : n.top || 0, r.right -= f ? n : n.right || 0, r.bottom -= f ? n : n.bottom || 0, r;
  } function Jt(t, e, i, n, o) {
    const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; if (t.indexOf('auto') === -1) return t; const s = Gt(i, n, r, o); const a = {
      top: { width: s.width, height: e.top - s.top }, right: { width: s.right - e.right, height: s.height }, bottom: { width: s.width, height: s.bottom - e.bottom }, left: { width: e.left - s.left, height: s.height },
    }; const l = Object.keys(a).map((t) => { return { key: t, ...a[t], area: (e = a[t], e.width * e.height) }; let e; }).sort((t, e) => e.area - t.area); const c = l.filter((t) => { const e = t.width; const n = t.height; return e >= i.clientWidth && n >= i.clientHeight; }); const h = c.length > 0 ? c[0].key : l[0].key; const u = t.split('-')[1]; return h + (u ? `-${u}` : '');
  } function Zt(t, e, n) { const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; return Xt(n, i ? zt(e) : Ft(e, n), i); } function $t(t) { const e = t.ownerDocument.defaultView.getComputedStyle(t); const n = parseFloat(e.marginTop || 0) + parseFloat(e.marginBottom || 0); const i = parseFloat(e.marginLeft || 0) + parseFloat(e.marginRight || 0); return { width: t.offsetWidth + i, height: t.offsetHeight + n }; } function te(t) {
    const e = {
      left: 'right', right: 'left', bottom: 'top', top: 'bottom',
    }; return t.replace(/left|right|bottom|top/g, (t) => e[t]);
  } function ee(t, e, n) { n = n.split('-')[0]; const i = $t(t); const o = { width: i.width, height: i.height }; const r = ['right', 'left'].indexOf(n) !== -1; const s = r ? 'top' : 'left'; const a = r ? 'left' : 'top'; const l = r ? 'height' : 'width'; const c = r ? 'width' : 'height'; return o[s] = e[s] + e[l] / 2 - i[l] / 2, o[a] = n === a ? e[a] - i[c] : e[te(a)], o; } function ne(t, e) { return Array.prototype.find ? t.find(e) : t.filter(e)[0]; } function ie(t, n, e) { return (void 0 === e ? t : t.slice(0, (function (t, e, n) { if (Array.prototype.findIndex) return t.findIndex((t) => t[e] === n); const i = ne(t, (t) => t[e] === n); return t.indexOf(i); }(t, 'name', e)))).forEach((t) => { t.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const e = t.function || t.fn; t.enabled && Ot(e) && (n.offsets.popper = Yt(n.offsets.popper), n.offsets.reference = Yt(n.offsets.reference), n = e(n, t)); }), n; } function oe(t, n) { return t.some((t) => { const e = t.name; return t.enabled && e === n; }); } function re(t) { for (let e = [!1, 'ms', 'Webkit', 'Moz', 'O'], n = t.charAt(0).toUpperCase() + t.slice(1), i = 0; i < e.length; i++) { const o = e[i]; const r = o ? `${o}${n}` : t; if (typeof document.body.style[r] !== 'undefined') return r; } return null; } function se(t) { const e = t.ownerDocument; return e ? e.defaultView : window; } function ae(t, e, n, i) { n.updateBound = i, se(t).addEventListener('resize', n.updateBound, { passive: !0 }); const o = Lt(t); return (function t(e, n, i, o) { const r = e.nodeName === 'BODY'; const s = r ? e.ownerDocument.defaultView : e; s.addEventListener(n, i, { passive: !0 }), r || t(Lt(s.parentNode), n, i, o), o.push(s); }(o, 'scroll', n.updateBound, n.scrollParents)), n.scrollElement = o, n.eventsEnabled = !0, n; } function le() { let t; let e; this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = (t = this.reference, e = this.state, se(t).removeEventListener('resize', e.updateBound), e.scrollParents.forEach((t) => { t.removeEventListener('scroll', e.updateBound); }), e.updateBound = null, e.scrollParents = [], e.scrollElement = null, e.eventsEnabled = !1, e)); } function ce(t) { return t !== '' && !isNaN(parseFloat(t)) && isFinite(t); } function he(n, i) { Object.keys(i).forEach((t) => { let e = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(t) !== -1 && ce(i[t]) && (e = 'px'), n.style[t] = i[t] + e; }); } const ue = Ct && /Firefox/i.test(navigator.userAgent); function fe(t, e, n) { const i = ne(t, (t) => t.name === e); const o = !!i && t.some((t) => t.name === n && t.enabled && t.order < i.order); if (!o) { const r = `\`${e}\``; const s = `\`${n}\``; console.warn(`${s} modifier is required by ${r} modifier in order to work, be sure to include it before ${r}!`); } return o; } const de = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; const pe = de.slice(3); function me(t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = pe.indexOf(t); const i = pe.slice(n + 1).concat(pe.slice(0, n)); return e ? i.reverse() : i; } const ge = 'flip'; const _e = 'clockwise'; const ve = 'counterclockwise'; function ye(t, o, r, e) {
    const s = [0, 0]; const a = ['right', 'left'].indexOf(e) !== -1; const n = t.split(/(\+|\-)/).map((t) => t.trim()); const i = n.indexOf(ne(n, (t) => t.search(/,|\s/) !== -1)); n[i] && n[i].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const l = /\s*,\s*|\s+/; let c = i !== -1 ? [n.slice(0, i).concat([n[i].split(l)[0]]), [n[i].split(l)[1]].concat(n.slice(i + 1))] : [n]; return (c = c.map((t, e) => {
      const n = (e === 1 ? !a : a) ? 'height' : 'width'; let
        i = !1; return t.reduce((t, e) => (t[t.length - 1] === '' && ['+', '-'].indexOf(e) !== -1 ? (t[t.length - 1] = e, i = !0, t) : i ? (t[t.length - 1] += e, i = !1, t) : t.concat(e)), []).map((t) => (function (t, e, n, i) { const o = t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const r = +o[1]; const s = o[2]; if (!r) return t; if (s.indexOf('%') !== 0) return s !== 'vh' && s !== 'vw' ? r : (s === 'vh' ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * r; let a = void 0; switch (s) { case '%p': a = n; break; case '%': case '%r': default: a = i; } return Yt(a)[e] / 100 * r; }(t, n, o, r)));
    })).forEach((n, i) => { n.forEach((t, e) => { ce(t) && (s[i] += t * (n[e - 1] === '-' ? -1 : 1)); }); }), s;
  } const Ee = {
    placement: 'bottom',
    positionFixed: !1,
    eventsEnabled: !0,
    removeOnDestroy: !1,
    onCreate() {},
    onUpdate() {},
    modifiers: {
      shift: { order: 100, enabled: !0, fn(t) { const e = t.placement; const n = e.split('-')[0]; const i = e.split('-')[1]; if (i) { const o = t.offsets; const r = o.reference; const s = o.popper; const a = ['bottom', 'top'].indexOf(n) !== -1; const l = a ? 'left' : 'top'; const c = a ? 'width' : 'height'; const h = { start: Kt({}, l, r[l]), end: Kt({}, l, r[l] + r[c] - s[c]) }; t.offsets.popper = { ...s, ...h[i] }; } return t; } },
      offset: {
        order: 200, enabled: !0, fn(t, e) { const n = e.offset; const i = t.placement; const o = t.offsets; const r = o.popper; const s = o.reference; const a = i.split('-')[0]; let l = void 0; return l = ce(+n) ? [+n, 0] : ye(n, r, s, a), a === 'left' ? (r.top += l[0], r.left -= l[1]) : a === 'right' ? (r.top += l[0], r.left += l[1]) : a === 'top' ? (r.left += l[0], r.top -= l[1]) : a === 'bottom' && (r.left += l[0], r.top += l[1]), t.popper = r, t; }, offset: 0,
      },
      preventOverflow: {
        order: 300,
        enabled: !0,
        fn(t, i) {
          let e = i.boundariesElement || jt(t.instance.popper); t.instance.reference === e && (e = jt(e)); const n = re('transform'); const o = t.instance.popper.style; const r = o.top; const s = o.left; const a = o[n]; o.top = '', o.left = '', o[n] = ''; const l = Gt(t.instance.popper, t.instance.reference, i.padding, e, t.positionFixed); o.top = r, o.left = s, o[n] = a, i.boundaries = l; const c = i.priority; let h = t.offsets.popper; const u = {
            primary(t) { let e = h[t]; return h[t] < l[t] && !i.escapeWithReference && (e = Math.max(h[t], l[t])), Kt({}, t, e); },
            secondary(t) {
              const e = t === 'right' ? 'left' : 'top'; let
                n = h[e]; return h[t] > l[t] && !i.escapeWithReference && (n = Math.min(h[e], l[t] - (t === 'right' ? h.width : h.height))), Kt({}, e, n);
            },
          }; return c.forEach((t) => { const e = ['left', 'top'].indexOf(t) !== -1 ? 'primary' : 'secondary'; h = { ...h, ...u[e](t) }; }), t.offsets.popper = h, t;
        },
        priority: ['left', 'right', 'top', 'bottom'],
        padding: 5,
        boundariesElement: 'scrollParent',
      },
      keepTogether: { order: 400, enabled: !0, fn(t) { const e = t.offsets; const n = e.popper; const i = e.reference; const o = t.placement.split('-')[0]; const r = Math.floor; const s = ['top', 'bottom'].indexOf(o) !== -1; const a = s ? 'right' : 'bottom'; const l = s ? 'left' : 'top'; const c = s ? 'width' : 'height'; return n[a] < r(i[l]) && (t.offsets.popper[l] = r(i[l]) - n[c]), n[l] > r(i[a]) && (t.offsets.popper[l] = r(i[a])), t; } },
      arrow: {
        order: 500, enabled: !0, fn(t, e) { let n; if (!fe(t.instance.modifiers, 'arrow', 'keepTogether')) return t; let i = e.element; if (typeof i === 'string') { if (!(i = t.instance.popper.querySelector(i))) return t; } else if (!t.instance.popper.contains(i)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), t; const o = t.placement.split('-')[0]; const r = t.offsets; const s = r.popper; const a = r.reference; const l = ['left', 'right'].indexOf(o) !== -1; const c = l ? 'height' : 'width'; const h = l ? 'Top' : 'Left'; const u = h.toLowerCase(); const f = l ? 'left' : 'top'; const d = l ? 'bottom' : 'right'; const p = $t(i)[c]; a[d] - p < s[u] && (t.offsets.popper[u] -= s[u] - (a[d] - p)), a[u] + p > s[d] && (t.offsets.popper[u] += a[u] + p - s[d]), t.offsets.popper = Yt(t.offsets.popper); const m = a[u] + a[c] / 2 - p / 2; const g = Nt(t.instance.popper); const _ = parseFloat(g[`margin${h}`], 10); const v = parseFloat(g[`border${h}Width`], 10); let y = m - t.offsets.popper[u] - _ - v; return y = Math.max(Math.min(s[c] - p, y), 0), t.arrowElement = i, t.offsets.arrow = (Kt(n = {}, u, Math.round(y)), Kt(n, f, ''), n), t; }, element: '[x-arrow]',
      },
      flip: {
        order: 600, enabled: !0, fn(p, m) { if (oe(p.instance.modifiers, 'inner')) return p; if (p.flipped && p.placement === p.originalPlacement) return p; const g = Gt(p.instance.popper, p.instance.reference, m.padding, m.boundariesElement, p.positionFixed); let _ = p.placement.split('-')[0]; let v = te(_); let y = p.placement.split('-')[1] || ''; let E = []; switch (m.behavior) { case ge: E = [_, v]; break; case _e: E = me(_); break; case ve: E = me(_, !0); break; default: E = m.behavior; } return E.forEach((t, e) => { if (_ !== t || E.length === e + 1) return p; _ = p.placement.split('-')[0], v = te(_); let n; const i = p.offsets.popper; const o = p.offsets.reference; const r = Math.floor; const s = _ === 'left' && r(i.right) > r(o.left) || _ === 'right' && r(i.left) < r(o.right) || _ === 'top' && r(i.bottom) > r(o.top) || _ === 'bottom' && r(i.top) < r(o.bottom); const a = r(i.left) < r(g.left); const l = r(i.right) > r(g.right); const c = r(i.top) < r(g.top); const h = r(i.bottom) > r(g.bottom); const u = _ === 'left' && a || _ === 'right' && l || _ === 'top' && c || _ === 'bottom' && h; const f = ['top', 'bottom'].indexOf(_) !== -1; const d = !!m.flipVariations && (f && y === 'start' && a || f && y === 'end' && l || !f && y === 'start' && c || !f && y === 'end' && h); (s || u || d) && (p.flipped = !0, (s || u) && (_ = E[e + 1]), d && (y = (n = y) === 'end' ? 'start' : n === 'start' ? 'end' : n), p.placement = _ + (y ? `-${y}` : ''), p.offsets.popper = { ...p.offsets.popper, ...ee(p.instance.popper, p.offsets.reference, p.placement) }, p = ie(p.instance.modifiers, p, 'flip')); }), p; }, behavior: 'flip', padding: 5, boundariesElement: 'viewport',
      },
      inner: { order: 700, enabled: !1, fn(t) { const e = t.placement; const n = e.split('-')[0]; const i = t.offsets; const o = i.popper; const r = i.reference; const s = ['left', 'right'].indexOf(n) !== -1; const a = ['top', 'left'].indexOf(n) === -1; return o[s ? 'left' : 'top'] = r[n] - (a ? o[s ? 'width' : 'height'] : 0), t.placement = te(e), t.offsets.popper = Yt(o), t; } },
      hide: { order: 800, enabled: !0, fn(t) { if (!fe(t.instance.modifiers, 'hide', 'preventOverflow')) return t; const e = t.offsets.reference; const n = ne(t.instance.modifiers, (t) => t.name === 'preventOverflow').boundaries; if (e.bottom < n.top || e.left > n.right || e.top > n.bottom || e.right < n.left) { if (!0 === t.hide) return t; t.hide = !0, t.attributes['x-out-of-boundaries'] = ''; } else { if (!1 === t.hide) return t; t.hide = !1, t.attributes['x-out-of-boundaries'] = !1; } return t; } },
      computeStyle: {
        order: 850,
        enabled: !0,
        fn(t, e) {
          const n = e.x; const i = e.y; const o = t.offsets.popper; const r = ne(t.instance.modifiers, (t) => t.name === 'applyStyle').gpuAcceleration; void 0 !== r && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); let s; let a; let l; let c; let h; let u; let f; let d; let p; let m; let g; let _; const v = void 0 !== r ? r : e.gpuAcceleration; const y = jt(t.instance.popper); const E = Vt(y); const b = { position: o.position }; const w = (s = t, a = window.devicePixelRatio < 2 || !ue, l = s.offsets, c = l.popper, h = l.reference, u = ['left', 'right'].indexOf(s.placement) !== -1, f = s.placement.indexOf('-') !== -1, d = h.width % 2 == c.width % 2, p = h.width % 2 == 1 && c.width % 2 == 1, m = function (t) { return t; }, g = a ? u || f || d ? Math.round : Math.floor : m, _ = a ? Math.round : m, {
            left: g(p && !f && a ? c.left - 1 : c.left), top: _(c.top), bottom: _(c.bottom), right: g(c.right),
          }); const T = n === 'bottom' ? 'top' : 'bottom'; const C = i === 'right' ? 'left' : 'right'; const S = re('transform'); let D = void 0; let I = void 0; if (I = T === 'bottom' ? y.nodeName === 'HTML' ? -y.clientHeight + w.bottom : -E.height + w.bottom : w.top, D = C === 'right' ? y.nodeName === 'HTML' ? -y.clientWidth + w.right : -E.width + w.right : w.left, v && S)b[S] = `translate3d(${D}px, ${I}px, 0)`, b[T] = 0, b[C] = 0, b.willChange = 'transform'; else { const A = T === 'bottom' ? -1 : 1; const O = C === 'right' ? -1 : 1; b[T] = I * A, b[C] = D * O, b.willChange = `${T}, ${C}`; } const N = { 'x-placement': t.placement }; return t.attributes = { ...N, ...t.attributes }, t.styles = { ...b, ...t.styles }, t.arrowStyles = { ...t.offsets.arrow, ...t.arrowStyles }, t;
        },
        gpuAcceleration: !0,
        x: 'bottom',
        y: 'right',
      },
      applyStyle: {
        order: 900, enabled: !0, fn(t) { let e; let n; return he(t.instance.popper, t.styles), e = t.instance.popper, n = t.attributes, Object.keys(n).forEach((t) => { !1 !== n[t] ? e.setAttribute(t, n[t]) : e.removeAttribute(t); }), t.arrowElement && Object.keys(t.arrowStyles).length && he(t.arrowElement, t.arrowStyles), t; }, onLoad(t, e, n, i, o) { const r = Zt(o, e, t, n.positionFixed); const s = Jt(n.placement, r, e, t, n.modifiers.flip.boundariesElement, n.modifiers.flip.padding); return e.setAttribute('x-placement', s), he(e, { position: n.positionFixed ? 'fixed' : 'absolute' }), n; }, gpuAcceleration: void 0,
      },
    },
  }; const be = (function () {
    function r(t, e) { const n = this; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; !(function (t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); }(this, r)), this.scheduleUpdate = function () { return requestAnimationFrame(n.update); }, this.update = At(this.update.bind(this)), this.options = { ...r.Defaults, ...i }, this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = t && t.jquery ? t[0] : t, this.popper = e && e.jquery ? e[0] : e, this.options.modifiers = {}, Object.keys({ ...r.Defaults.modifiers, ...i.modifiers }).forEach((t) => { n.options.modifiers[t] = { ...r.Defaults.modifiers[t] || {}, ...(i.modifiers ? i.modifiers[t] : {}) }; }), this.modifiers = Object.keys(this.options.modifiers).map((t) => ({ name: t, ...n.options.modifiers[t] })).sort((t, e) => t.order - e.order), this.modifiers.forEach((t) => { t.enabled && Ot(t.onLoad) && t.onLoad(n.reference, n.popper, n.options, t, n.state); }), this.update(); const o = this.options.eventsEnabled; o && this.enableEventListeners(), this.state.eventsEnabled = o; } return qt(r, [{
      key: 'update',
      value() {
        return function () {
          if (!this.state.isDestroyed) {
            let t = {
              instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {},
            }; t.offsets.reference = Zt(this.state, this.popper, this.reference, this.options.positionFixed), t.placement = Jt(this.options.placement, t.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), t.originalPlacement = t.placement, t.positionFixed = this.options.positionFixed, t.offsets.popper = ee(this.popper, t.offsets.reference, t.placement), t.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', t = ie(this.modifiers, t), this.state.isCreated ? this.options.onUpdate(t) : (this.state.isCreated = !0, this.options.onCreate(t));
          }
        }.call(this);
      },
    }, { key: 'destroy', value() { return function () { return this.state.isDestroyed = !0, oe(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[re('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this; }.call(this); } }, { key: 'enableEventListeners', value() { return function () { this.state.eventsEnabled || (this.state = ae(this.reference, this.options, this.state, this.scheduleUpdate)); }.call(this); } }, { key: 'disableEventListeners', value() { return le.call(this); } }]), r;
  }()); be.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils, be.placements = de, be.Defaults = Ee; const we = 'dropdown'; const Te = 'bs.dropdown'; const Ce = `.${Te}`; const Se = '.data-api'; const De = p.fn[we]; const Ie = new RegExp('38|40|27'); const Ae = {
    HIDE: `hide${Ce}`, HIDDEN: `hidden${Ce}`, SHOW: `show${Ce}`, SHOWN: `shown${Ce}`, CLICK: `click${Ce}`, CLICK_DATA_API: `click${Ce}${Se}`, KEYDOWN_DATA_API: `keydown${Ce}${Se}`, KEYUP_DATA_API: `keyup${Ce}${Se}`,
  }; const Oe = 'disabled'; const Ne = 'show'; const ke = 'dropup'; const Le = 'dropright'; const Pe = 'dropleft'; const xe = 'dropdown-menu-right'; const He = 'position-static'; const je = '[data-toggle="dropdown"]'; const Re = '.dropdown form'; const Fe = '.dropdown-menu'; const Me = '.navbar-nav'; const We = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'; const Ue = 'top-start'; const Be = 'top-end'; const qe = 'bottom-start'; const Ke = 'bottom-end'; const Qe = 'right-start'; const Ye = 'left-start'; const Ve = {
    offset: 0, flip: !0, boundary: 'scrollParent', reference: 'toggle', display: 'dynamic',
  }; const Xe = {
    offset: '(number|string|function)', flip: 'boolean', boundary: '(string|element)', reference: '(string|element)', display: 'string',
  }; const ze = (function () { function c(t, e) { this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners(); } const t = c.prototype; return t.toggle = function () { if (!this._element.disabled && !p(this._element).hasClass(Oe)) { const t = c._getParentFromElement(this._element); const e = p(this._menu).hasClass(Ne); if (c._clearMenus(), !e) { const n = { relatedTarget: this._element }; const i = p.Event(Ae.SHOW, n); if (p(t).trigger(i), !i.isDefaultPrevented()) { if (!this._inNavbar) { if (typeof be === 'undefined') throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)"); let o = this._element; this._config.reference === 'parent' ? o = t : m.isElement(this._config.reference) && (o = this._config.reference, typeof this._config.reference.jquery !== 'undefined' && (o = this._config.reference[0])), this._config.boundary !== 'scrollParent' && p(t).addClass(He), this._popper = new be(o, this._menu, this._getPopperConfig()); }'ontouchstart' in document.documentElement && p(t).closest(Me).length === 0 && p(document.body).children().on('mouseover', null, p.noop), this._element.focus(), this._element.setAttribute('aria-expanded', !0), p(this._menu).toggleClass(Ne), p(t).toggleClass(Ne).trigger(p.Event(Ae.SHOWN, n)); } } } }, t.show = function () { if (!(this._element.disabled || p(this._element).hasClass(Oe) || p(this._menu).hasClass(Ne))) { const t = { relatedTarget: this._element }; const e = p.Event(Ae.SHOW, t); const n = c._getParentFromElement(this._element); p(n).trigger(e), e.isDefaultPrevented() || (p(this._menu).toggleClass(Ne), p(n).toggleClass(Ne).trigger(p.Event(Ae.SHOWN, t))); } }, t.hide = function () { if (!this._element.disabled && !p(this._element).hasClass(Oe) && p(this._menu).hasClass(Ne)) { const t = { relatedTarget: this._element }; const e = p.Event(Ae.HIDE, t); const n = c._getParentFromElement(this._element); p(n).trigger(e), e.isDefaultPrevented() || (p(this._menu).toggleClass(Ne), p(n).toggleClass(Ne).trigger(p.Event(Ae.HIDDEN, t))); } }, t.dispose = function () { p.removeData(this._element, Te), p(this._element).off(Ce), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null); }, t.update = function () { this._inNavbar = this._detectNavbar(), this._popper !== null && this._popper.scheduleUpdate(); }, t._addEventListeners = function () { const e = this; p(this._element).on(Ae.CLICK, (t) => { t.preventDefault(), t.stopPropagation(), e.toggle(); }); }, t._getConfig = function (t) { return t = l({}, this.constructor.Default, p(this._element).data(), t), m.typeCheckConfig(we, t, this.constructor.DefaultType), t; }, t._getMenuElement = function () { if (!this._menu) { const t = c._getParentFromElement(this._element); t && (this._menu = t.querySelector(Fe)); } return this._menu; }, t._getPlacement = function () { const t = p(this._element.parentNode); let e = qe; return t.hasClass(ke) ? (e = Ue, p(this._menu).hasClass(xe) && (e = Be)) : t.hasClass(Le) ? e = Qe : t.hasClass(Pe) ? e = Ye : p(this._menu).hasClass(xe) && (e = Ke), e; }, t._detectNavbar = function () { return p(this._element).closest('.navbar').length > 0; }, t._getPopperConfig = function () { const e = this; const t = {}; typeof this._config.offset === 'function' ? t.fn = function (t) { return t.offsets = l({}, t.offsets, e._config.offset(t.offsets) || {}), t; } : t.offset = this._config.offset; const n = { placement: this._getPlacement(), modifiers: { offset: t, flip: { enabled: this._config.flip }, preventOverflow: { boundariesElement: this._config.boundary } } }; return this._config.display === 'static' && (n.modifiers.applyStyle = { enabled: !1 }), n; }, c._jQueryInterface = function (e) { return this.each(function () { let t = p(this).data(Te); if (t || (t = new c(this, typeof e === 'object' ? e : null), p(this).data(Te, t)), typeof e === 'string') { if (typeof t[e] === 'undefined') throw new TypeError(`No method named "${e}"`); t[e](); } }); }, c._clearMenus = function (t) { if (!t || t.which !== 3 && (t.type !== 'keyup' || t.which === 9)) for (let e = [].slice.call(document.querySelectorAll(je)), n = 0, i = e.length; n < i; n++) { const o = c._getParentFromElement(e[n]); const r = p(e[n]).data(Te); const s = { relatedTarget: e[n] }; if (t && t.type === 'click' && (s.clickEvent = t), r) { const a = r._menu; if (p(o).hasClass(Ne) && !(t && (t.type === 'click' && /input|textarea/i.test(t.target.tagName) || t.type === 'keyup' && t.which === 9) && p.contains(o, t.target))) { const l = p.Event(Ae.HIDE, s); p(o).trigger(l), l.isDefaultPrevented() || ('ontouchstart' in document.documentElement && p(document.body).children().off('mouseover', null, p.noop), e[n].setAttribute('aria-expanded', 'false'), p(a).removeClass(Ne), p(o).removeClass(Ne).trigger(p.Event(Ae.HIDDEN, s))); } } } }, c._getParentFromElement = function (t) { let e; const n = m.getSelectorFromElement(t); return n && (e = document.querySelector(n)), e || t.parentNode; }, c._dataApiKeydownHandler = function (t) { if ((/input|textarea/i.test(t.target.tagName) ? !(t.which === 32 || t.which !== 27 && (t.which !== 40 && t.which !== 38 || p(t.target).closest(Fe).length)) : Ie.test(t.which)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !p(this).hasClass(Oe))) { const e = c._getParentFromElement(this); const n = p(e).hasClass(Ne); if (n && (!n || t.which !== 27 && t.which !== 32)) { const i = [].slice.call(e.querySelectorAll(We)); if (i.length !== 0) { let o = i.indexOf(t.target); t.which === 38 && o > 0 && o--, t.which === 40 && o < i.length - 1 && o++, o < 0 && (o = 0), i[o].focus(); } } else { if (t.which === 27) { const r = e.querySelector(je); p(r).trigger('focus'); }p(this).trigger('click'); } } }, s(c, null, [{ key: 'VERSION', get() { return '4.2.1'; } }, { key: 'Default', get() { return Ve; } }, { key: 'DefaultType', get() { return Xe; } }]), c; }()); p(document).on(Ae.KEYDOWN_DATA_API, je, ze._dataApiKeydownHandler).on(Ae.KEYDOWN_DATA_API, Fe, ze._dataApiKeydownHandler).on(`${Ae.CLICK_DATA_API} ${Ae.KEYUP_DATA_API}`, ze._clearMenus)
    .on(Ae.CLICK_DATA_API, je, function (t) { t.preventDefault(), t.stopPropagation(), ze._jQueryInterface.call(p(this), 'toggle'); })
    .on(Ae.CLICK_DATA_API, Re, (t) => { t.stopPropagation(); }), p.fn[we] = ze._jQueryInterface, p.fn[we].Constructor = ze, p.fn[we].noConflict = function () { return p.fn[we] = De, ze._jQueryInterface; }; const Ge = 'modal'; const Je = 'bs.modal'; const Ze = `.${Je}`; const $e = p.fn[Ge]; const tn = {
    backdrop: !0, keyboard: !0, focus: !0, show: !0,
  }; const en = {
    backdrop: '(boolean|string)', keyboard: 'boolean', focus: 'boolean', show: 'boolean',
  }; const nn = {
    HIDE: `hide${Ze}`, HIDDEN: `hidden${Ze}`, SHOW: `show${Ze}`, SHOWN: `shown${Ze}`, FOCUSIN: `focusin${Ze}`, RESIZE: `resize${Ze}`, CLICK_DISMISS: `click.dismiss${Ze}`, KEYDOWN_DISMISS: `keydown.dismiss${Ze}`, MOUSEUP_DISMISS: `mouseup.dismiss${Ze}`, MOUSEDOWN_DISMISS: `mousedown.dismiss${Ze}`, CLICK_DATA_API: `click${Ze}.data-api`,
  }; const on = 'modal-scrollbar-measure'; const rn = 'modal-backdrop'; const sn = 'modal-open'; const an = 'fade'; const ln = 'show'; const cn = '.modal-dialog'; const hn = '[data-toggle="modal"]'; const un = '[data-dismiss="modal"]'; const fn = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'; const dn = '.sticky-top'; const pn = (function () { function o(t, e) { this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(cn), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0; } const t = o.prototype; return t.toggle = function (t) { return this._isShown ? this.hide() : this.show(t); }, t.show = function (t) { const e = this; if (!this._isShown && !this._isTransitioning) { p(this._element).hasClass(an) && (this._isTransitioning = !0); const n = p.Event(nn.SHOW, { relatedTarget: t }); p(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), p(this._element).on(nn.CLICK_DISMISS, un, (t) => e.hide(t)), p(this._dialog).on(nn.MOUSEDOWN_DISMISS, () => { p(e._element).one(nn.MOUSEUP_DISMISS, (t) => { p(t.target).is(e._element) && (e._ignoreBackdropClick = !0); }); }), this._showBackdrop(() => e._showElement(t))); } }, t.hide = function (t) { const e = this; if (t && t.preventDefault(), this._isShown && !this._isTransitioning) { const n = p.Event(nn.HIDE); if (p(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) { this._isShown = !1; const i = p(this._element).hasClass(an); if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), p(document).off(nn.FOCUSIN), p(this._element).removeClass(ln), p(this._element).off(nn.CLICK_DISMISS), p(this._dialog).off(nn.MOUSEDOWN_DISMISS), i) { const o = m.getTransitionDurationFromElement(this._element); p(this._element).one(m.TRANSITION_END, (t) => e._hideModal(t)).emulateTransitionEnd(o); } else this._hideModal(); } } }, t.dispose = function () { [window, this._element, this._dialog].forEach((t) => p(t).off(Ze)), p(document).off(nn.FOCUSIN), p.removeData(this._element, Je), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null; }, t.handleUpdate = function () { this._adjustDialog(); }, t._getConfig = function (t) { return t = l({}, tn, t), m.typeCheckConfig(Ge, t, en), t; }, t._showElement = function (t) { const e = this; const n = p(this._element).hasClass(an); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.scrollTop = 0, n && m.reflow(this._element), p(this._element).addClass(ln), this._config.focus && this._enforceFocus(); const i = p.Event(nn.SHOWN, { relatedTarget: t }); const o = function () { e._config.focus && e._element.focus(), e._isTransitioning = !1, p(e._element).trigger(i); }; if (n) { const r = m.getTransitionDurationFromElement(this._dialog); p(this._dialog).one(m.TRANSITION_END, o).emulateTransitionEnd(r); } else o(); }, t._enforceFocus = function () { const e = this; p(document).off(nn.FOCUSIN).on(nn.FOCUSIN, (t) => { document !== t.target && e._element !== t.target && p(e._element).has(t.target).length === 0 && e._element.focus(); }); }, t._setEscapeEvent = function () { const e = this; this._isShown && this._config.keyboard ? p(this._element).on(nn.KEYDOWN_DISMISS, (t) => { t.which === 27 && (t.preventDefault(), e.hide()); }) : this._isShown || p(this._element).off(nn.KEYDOWN_DISMISS); }, t._setResizeEvent = function () { const e = this; this._isShown ? p(window).on(nn.RESIZE, (t) => e.handleUpdate(t)) : p(window).off(nn.RESIZE); }, t._hideModal = function () { const t = this; this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._isTransitioning = !1, this._showBackdrop(() => { p(document.body).removeClass(sn), t._resetAdjustments(), t._resetScrollbar(), p(t._element).trigger(nn.HIDDEN); }); }, t._removeBackdrop = function () { this._backdrop && (p(this._backdrop).remove(), this._backdrop = null); }, t._showBackdrop = function (t) { const e = this; const n = p(this._element).hasClass(an) ? an : ''; if (this._isShown && this._config.backdrop) { if (this._backdrop = document.createElement('div'), this._backdrop.className = rn, n && this._backdrop.classList.add(n), p(this._backdrop).appendTo(document.body), p(this._element).on(nn.CLICK_DISMISS, (t) => { e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && (e._config.backdrop === 'static' ? e._element.focus() : e.hide()); }), n && m.reflow(this._backdrop), p(this._backdrop).addClass(ln), !t) return; if (!n) return void t(); const i = m.getTransitionDurationFromElement(this._backdrop); p(this._backdrop).one(m.TRANSITION_END, t).emulateTransitionEnd(i); } else if (!this._isShown && this._backdrop) { p(this._backdrop).removeClass(ln); const o = function () { e._removeBackdrop(), t && t(); }; if (p(this._element).hasClass(an)) { const r = m.getTransitionDurationFromElement(this._backdrop); p(this._backdrop).one(m.TRANSITION_END, o).emulateTransitionEnd(r); } else o(); } else t && t(); }, t._adjustDialog = function () { const t = this._element.scrollHeight > document.documentElement.clientHeight; !this._isBodyOverflowing && t && (this._element.style.paddingLeft = `${this._scrollbarWidth}px`), this._isBodyOverflowing && !t && (this._element.style.paddingRight = `${this._scrollbarWidth}px`); }, t._resetAdjustments = function () { this._element.style.paddingLeft = '', this._element.style.paddingRight = ''; }, t._checkScrollbar = function () { const t = document.body.getBoundingClientRect(); this._isBodyOverflowing = t.left + t.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth(); }, t._setScrollbar = function () { const o = this; if (this._isBodyOverflowing) { const t = [].slice.call(document.querySelectorAll(fn)); const e = [].slice.call(document.querySelectorAll(dn)); p(t).each((t, e) => { const n = e.style.paddingRight; const i = p(e).css('padding-right'); p(e).data('padding-right', n).css('padding-right', `${parseFloat(i) + o._scrollbarWidth}px`); }), p(e).each((t, e) => { const n = e.style.marginRight; const i = p(e).css('margin-right'); p(e).data('margin-right', n).css('margin-right', `${parseFloat(i) - o._scrollbarWidth}px`); }); const n = document.body.style.paddingRight; const i = p(document.body).css('padding-right'); p(document.body).data('padding-right', n).css('padding-right', `${parseFloat(i) + this._scrollbarWidth}px`); }p(document.body).addClass(sn); }, t._resetScrollbar = function () { const t = [].slice.call(document.querySelectorAll(fn)); p(t).each((t, e) => { const n = p(e).data('padding-right'); p(e).removeData('padding-right'), e.style.paddingRight = n || ''; }); const e = [].slice.call(document.querySelectorAll(`${dn}`)); p(e).each((t, e) => { const n = p(e).data('margin-right'); typeof n !== 'undefined' && p(e).css('margin-right', n).removeData('margin-right'); }); const n = p(document.body).data('padding-right'); p(document.body).removeData('padding-right'), document.body.style.paddingRight = n || ''; }, t._getScrollbarWidth = function () { const t = document.createElement('div'); t.className = on, document.body.appendChild(t); const e = t.getBoundingClientRect().width - t.clientWidth; return document.body.removeChild(t), e; }, o._jQueryInterface = function (n, i) { return this.each(function () { let t = p(this).data(Je); const e = l({}, tn, p(this).data(), typeof n === 'object' && n ? n : {}); if (t || (t = new o(this, e), p(this).data(Je, t)), typeof n === 'string') { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n](i); } else e.show && t.show(i); }); }, s(o, null, [{ key: 'VERSION', get() { return '4.2.1'; } }, { key: 'Default', get() { return tn; } }]), o; }()); p(document).on(nn.CLICK_DATA_API, hn, function (t) { let e; const n = this; const i = m.getSelectorFromElement(this); i && (e = document.querySelector(i)); const o = p(e).data(Je) ? 'toggle' : l({}, p(e).data(), p(this).data()); this.tagName !== 'A' && this.tagName !== 'AREA' || t.preventDefault(); var r = p(e).one(nn.SHOW, (t) => { t.isDefaultPrevented() || r.one(nn.HIDDEN, () => { p(n).is(':visible') && n.focus(); }); }); pn._jQueryInterface.call(p(e), o, this); }), p.fn[Ge] = pn._jQueryInterface, p.fn[Ge].Constructor = pn, p.fn[Ge].noConflict = function () { return p.fn[Ge] = $e, pn._jQueryInterface; }; const mn = 'tooltip'; const gn = 'bs.tooltip'; const _n = `.${gn}`; const vn = p.fn[mn]; const yn = 'bs-tooltip'; const En = new RegExp(`(^|\\s)${yn}\\S+`, 'g'); const bn = {
    animation: 'boolean', template: 'string', title: '(string|element|function)', trigger: 'string', delay: '(number|object)', html: 'boolean', selector: '(string|boolean)', placement: '(string|function)', offset: '(number|string)', container: '(string|element|boolean)', fallbackPlacement: '(string|array)', boundary: '(string|element)',
  }; const wn = {
    AUTO: 'auto', TOP: 'top', RIGHT: 'right', BOTTOM: 'bottom', LEFT: 'left',
  }; const Tn = {
    animation: !0, template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>', trigger: 'hover focus', title: '', delay: 0, html: !1, selector: !1, placement: 'top', offset: 0, container: !1, fallbackPlacement: 'flip', boundary: 'scrollParent',
  }; const Cn = 'show'; const Sn = 'out'; const Dn = {
    HIDE: `hide${_n}`, HIDDEN: `hidden${_n}`, SHOW: `show${_n}`, SHOWN: `shown${_n}`, INSERTED: `inserted${_n}`, CLICK: `click${_n}`, FOCUSIN: `focusin${_n}`, FOCUSOUT: `focusout${_n}`, MOUSEENTER: `mouseenter${_n}`, MOUSELEAVE: `mouseleave${_n}`,
  }; const In = 'fade'; const An = 'show'; const On = '.tooltip-inner'; const Nn = '.arrow'; const kn = 'hover'; const Ln = 'focus'; const Pn = 'click'; const xn = 'manual'; const Hn = (function () {
    function i(t, e) { if (typeof be === 'undefined') throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)"); this._isEnabled = !0, this._timeout = 0, this._hoverState = '', this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners(); } const t = i.prototype; return t.enable = function () { this._isEnabled = !0; }, t.disable = function () { this._isEnabled = !1; }, t.toggleEnabled = function () { this._isEnabled = !this._isEnabled; }, t.toggle = function (t) { if (this._isEnabled) if (t) { const e = this.constructor.DATA_KEY; let n = p(t.currentTarget).data(e); n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), p(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n); } else { if (p(this.getTipElement()).hasClass(An)) return void this._leave(null, this); this._enter(null, this); } }, t.dispose = function () { clearTimeout(this._timeout), p.removeData(this.element, this.constructor.DATA_KEY), p(this.element).off(this.constructor.EVENT_KEY), p(this.element).closest('.modal').off('hide.bs.modal'), this.tip && p(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null; }, t.show = function () {
      const e = this; if (p(this.element).css('display') === 'none') throw new Error('Please use show on visible elements'); const t = p.Event(this.constructor.Event.SHOW); if (this.isWithContent() && this._isEnabled) {
        p(this.element).trigger(t); const n = m.findShadowRoot(this.element); const i = p.contains(n !== null ? n : this.element.ownerDocument.documentElement, this.element); if (t.isDefaultPrevented() || !i) return; const o = this.getTipElement(); const r = m.getUID(this.constructor.NAME); o.setAttribute('id', r), this.element.setAttribute('aria-describedby', r), this.setContent(), this.config.animation && p(o).addClass(In); const s = typeof this.config.placement === 'function' ? this.config.placement.call(this, o, this.element) : this.config.placement; const a = this._getAttachment(s); this.addAttachmentClass(a); const l = this._getContainer(); p(o).data(this.constructor.DATA_KEY, this), p.contains(this.element.ownerDocument.documentElement, this.tip) || p(o).appendTo(l), p(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new be(this.element, o, {
          placement: a,
          modifiers: {
            offset: { offset: this.config.offset }, flip: { behavior: this.config.fallbackPlacement }, arrow: { element: Nn }, preventOverflow: { boundariesElement: this.config.boundary },
          },
          onCreate(t) { t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t); },
          onUpdate(t) { return e._handlePopperPlacementChange(t); },
        }), p(o).addClass(An), 'ontouchstart' in document.documentElement && p(document.body).children().on('mouseover', null, p.noop); const c = function () { e.config.animation && e._fixTransition(); const t = e._hoverState; e._hoverState = null, p(e.element).trigger(e.constructor.Event.SHOWN), t === Sn && e._leave(null, e); }; if (p(this.tip).hasClass(In)) { const h = m.getTransitionDurationFromElement(this.tip); p(this.tip).one(m.TRANSITION_END, c).emulateTransitionEnd(h); } else c();
      }
    }, t.hide = function (t) { const e = this; const n = this.getTipElement(); const i = p.Event(this.constructor.Event.HIDE); const o = function () { e._hoverState !== Cn && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute('aria-describedby'), p(e.element).trigger(e.constructor.Event.HIDDEN), e._popper !== null && e._popper.destroy(), t && t(); }; if (p(this.element).trigger(i), !i.isDefaultPrevented()) { if (p(n).removeClass(An), 'ontouchstart' in document.documentElement && p(document.body).children().off('mouseover', null, p.noop), this._activeTrigger[Pn] = !1, this._activeTrigger[Ln] = !1, this._activeTrigger[kn] = !1, p(this.tip).hasClass(In)) { const r = m.getTransitionDurationFromElement(n); p(n).one(m.TRANSITION_END, o).emulateTransitionEnd(r); } else o(); this._hoverState = ''; } }, t.update = function () { this._popper !== null && this._popper.scheduleUpdate(); }, t.isWithContent = function () { return Boolean(this.getTitle()); }, t.addAttachmentClass = function (t) { p(this.getTipElement()).addClass(`${yn}-${t}`); }, t.getTipElement = function () { return this.tip = this.tip || p(this.config.template)[0], this.tip; }, t.setContent = function () { const t = this.getTipElement(); this.setElementContent(p(t.querySelectorAll(On)), this.getTitle()), p(t).removeClass(`${In} ${An}`); }, t.setElementContent = function (t, e) { const n = this.config.html; typeof e === 'object' && (e.nodeType || e.jquery) ? n ? p(e).parent().is(t) || t.empty().append(e) : t.text(p(e).text()) : t[n ? 'html' : 'text'](e); }, t.getTitle = function () { let t = this.element.getAttribute('data-original-title'); return t || (t = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title), t; }, t._getContainer = function () { return !1 === this.config.container ? document.body : m.isElement(this.config.container) ? p(this.config.container) : p(document).find(this.config.container); }, t._getAttachment = function (t) { return wn[t.toUpperCase()]; }, t._setListeners = function () { const i = this; this.config.trigger.split(' ').forEach((t) => { if (t === 'click')p(i.element).on(i.constructor.Event.CLICK, i.config.selector, (t) => i.toggle(t)); else if (t !== xn) { const e = t === kn ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN; const n = t === kn ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT; p(i.element).on(e, i.config.selector, (t) => i._enter(t)).on(n, i.config.selector, (t) => i._leave(t)); } }), p(this.element).closest('.modal').on('hide.bs.modal', () => { i.element && i.hide(); }), this.config.selector ? this.config = l({}, this.config, { trigger: 'manual', selector: '' }) : this._fixTitle(); }, t._fixTitle = function () { const t = typeof this.element.getAttribute('data-original-title'); (this.element.getAttribute('title') || t !== 'string') && (this.element.setAttribute('data-original-title', this.element.getAttribute('title') || ''), this.element.setAttribute('title', '')); }, t._enter = function (t, e) { const n = this.constructor.DATA_KEY; (e = e || p(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), p(t.currentTarget).data(n, e)), t && (e._activeTrigger[t.type === 'focusin' ? Ln : kn] = !0), p(e.getTipElement()).hasClass(An) || e._hoverState === Cn ? e._hoverState = Cn : (clearTimeout(e._timeout), e._hoverState = Cn, e.config.delay && e.config.delay.show ? e._timeout = setTimeout(() => { e._hoverState === Cn && e.show(); }, e.config.delay.show) : e.show()); }, t._leave = function (t, e) { const n = this.constructor.DATA_KEY; (e = e || p(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), p(t.currentTarget).data(n, e)), t && (e._activeTrigger[t.type === 'focusout' ? Ln : kn] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = Sn, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(() => { e._hoverState === Sn && e.hide(); }, e.config.delay.hide) : e.hide()); }, t._isWithActiveTrigger = function () { for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0; return !1; }, t._getConfig = function (t) { return typeof (t = l({}, this.constructor.Default, p(this.element).data(), typeof t === 'object' && t ? t : {})).delay === 'number' && (t.delay = { show: t.delay, hide: t.delay }), typeof t.title === 'number' && (t.title = t.title.toString()), typeof t.content === 'number' && (t.content = t.content.toString()), m.typeCheckConfig(mn, t, this.constructor.DefaultType), t; }, t._getDelegateConfig = function () { const t = {}; if (this.config) for (const e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]); return t; }, t._cleanTipClass = function () { const t = p(this.getTipElement()); const e = t.attr('class').match(En); e !== null && e.length && t.removeClass(e.join('')); }, t._handlePopperPlacementChange = function (t) { const e = t.instance; this.tip = e.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement)); }, t._fixTransition = function () { const t = this.getTipElement(); const e = this.config.animation; t.getAttribute('x-placement') === null && (p(t).removeClass(In), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e); }, i._jQueryInterface = function (n) { return this.each(function () { let t = p(this).data(gn); const e = typeof n === 'object' && n; if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), p(this).data(gn, t)), typeof n === 'string')) { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n](); } }); }, s(i, null, [{ key: 'VERSION', get() { return '4.2.1'; } }, { key: 'Default', get() { return Tn; } }, { key: 'NAME', get() { return mn; } }, { key: 'DATA_KEY', get() { return gn; } }, { key: 'Event', get() { return Dn; } }, { key: 'EVENT_KEY', get() { return _n; } }, { key: 'DefaultType', get() { return bn; } }]), i;
  }()); p.fn[mn] = Hn._jQueryInterface, p.fn[mn].Constructor = Hn, p.fn[mn].noConflict = function () { return p.fn[mn] = vn, Hn._jQueryInterface; }; const jn = 'popover'; const Rn = 'bs.popover'; const Fn = `.${Rn}`; const Mn = p.fn[jn]; const Wn = 'bs-popover'; const Un = new RegExp(`(^|\\s)${Wn}\\S+`, 'g'); const Bn = l({}, Hn.Default, {
    placement: 'right', trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  }); const qn = l({}, Hn.DefaultType, { content: '(string|element|function)' }); const Kn = 'fade'; const Qn = 'show'; const Yn = '.popover-header'; const Vn = '.popover-body'; const Xn = {
    HIDE: `hide${Fn}`, HIDDEN: `hidden${Fn}`, SHOW: `show${Fn}`, SHOWN: `shown${Fn}`, INSERTED: `inserted${Fn}`, CLICK: `click${Fn}`, FOCUSIN: `focusin${Fn}`, FOCUSOUT: `focusout${Fn}`, MOUSEENTER: `mouseenter${Fn}`, MOUSELEAVE: `mouseleave${Fn}`,
  }; const zn = (function (t) { let e; let n; function i() { return t.apply(this, arguments) || this; }n = t, (e = i).prototype = Object.create(n.prototype), (e.prototype.constructor = e).__proto__ = n; const o = i.prototype; return o.isWithContent = function () { return this.getTitle() || this._getContent(); }, o.addAttachmentClass = function (t) { p(this.getTipElement()).addClass(`${Wn}-${t}`); }, o.getTipElement = function () { return this.tip = this.tip || p(this.config.template)[0], this.tip; }, o.setContent = function () { const t = p(this.getTipElement()); this.setElementContent(t.find(Yn), this.getTitle()); let e = this._getContent(); typeof e === 'function' && (e = e.call(this.element)), this.setElementContent(t.find(Vn), e), t.removeClass(`${Kn} ${Qn}`); }, o._getContent = function () { return this.element.getAttribute('data-content') || this.config.content; }, o._cleanTipClass = function () { const t = p(this.getTipElement()); const e = t.attr('class').match(Un); e !== null && e.length > 0 && t.removeClass(e.join('')); }, i._jQueryInterface = function (n) { return this.each(function () { let t = p(this).data(Rn); const e = typeof n === 'object' ? n : null; if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), p(this).data(Rn, t)), typeof n === 'string')) { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n](); } }); }, s(i, null, [{ key: 'VERSION', get() { return '4.2.1'; } }, { key: 'Default', get() { return Bn; } }, { key: 'NAME', get() { return jn; } }, { key: 'DATA_KEY', get() { return Rn; } }, { key: 'Event', get() { return Xn; } }, { key: 'EVENT_KEY', get() { return Fn; } }, { key: 'DefaultType', get() { return qn; } }]), i; }(Hn)); p.fn[jn] = zn._jQueryInterface, p.fn[jn].Constructor = zn, p.fn[jn].noConflict = function () { return p.fn[jn] = Mn, zn._jQueryInterface; }; const Gn = 'scrollspy'; const Jn = 'bs.scrollspy'; const Zn = `.${Jn}`; const $n = p.fn[Gn]; const ti = { offset: 10, method: 'auto', target: '' }; const ei = { offset: 'number', method: 'string', target: '(string|element)' }; const ni = { ACTIVATE: `activate${Zn}`, SCROLL: `scroll${Zn}`, LOAD_DATA_API: `load${Zn}.data-api` }; const ii = 'dropdown-item'; const oi = 'active'; const ri = '[data-spy="scroll"]'; const si = '.nav, .list-group'; const ai = '.nav-link'; const li = '.nav-item'; const ci = '.list-group-item'; const hi = '.dropdown'; const ui = '.dropdown-item'; const fi = '.dropdown-toggle'; const di = 'offset'; const pi = 'position'; const mi = (function () {
    function n(t, e) { const n = this; this._element = t, this._scrollElement = t.tagName === 'BODY' ? window : t, this._config = this._getConfig(e), this._selector = `${this._config.target} ${ai},${this._config.target} ${ci},${this._config.target} ${ui}`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, p(this._scrollElement).on(ni.SCROLL, (t) => n._process(t)), this.refresh(), this._process(); } const t = n.prototype; return t.refresh = function () {
      const e = this; const t = this._scrollElement === this._scrollElement.window ? di : pi; const o = this._config.method === 'auto' ? t : this._config.method; const r = o === pi ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map((t) => { let e; const n = m.getSelectorFromElement(t); if (n && (e = document.querySelector(n)), e) { const i = e.getBoundingClientRect(); if (i.width || i.height) return [p(e)[o]().top + r, n]; } return null; }).filter((t) => t).sort((t, e) => t[0] - e[0])
        .forEach((t) => { e._offsets.push(t[0]), e._targets.push(t[1]); });
    }, t.dispose = function () { p.removeData(this._element, Jn), p(this._scrollElement).off(Zn), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null; }, t._getConfig = function (t) { if (typeof (t = l({}, ti, typeof t === 'object' && t ? t : {})).target !== 'string') { let e = p(t.target).attr('id'); e || (e = m.getUID(Gn), p(t.target).attr('id', e)), t.target = `#${e}`; } return m.typeCheckConfig(Gn, t, ei), t; }, t._getScrollTop = function () { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop; }, t._getScrollHeight = function () { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight); }, t._getOffsetHeight = function () { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height; }, t._process = function () { const t = this._getScrollTop() + this._config.offset; const e = this._getScrollHeight(); const n = this._config.offset + e - this._getOffsetHeight(); if (this._scrollHeight !== e && this.refresh(), n <= t) { const i = this._targets[this._targets.length - 1]; this._activeTarget !== i && this._activate(i); } else { if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let o = this._offsets.length; o--;) { this._activeTarget !== this._targets[o] && t >= this._offsets[o] && (typeof this._offsets[o + 1] === 'undefined' || t < this._offsets[o + 1]) && this._activate(this._targets[o]); } } }, t._activate = function (e) { this._activeTarget = e, this._clear(); const t = this._selector.split(',').map((t) => `${t}[data-target="${e}"],${t}[href="${e}"]`); const n = p([].slice.call(document.querySelectorAll(t.join(',')))); n.hasClass(ii) ? (n.closest(hi).find(fi).addClass(oi), n.addClass(oi)) : (n.addClass(oi), n.parents(si).prev(`${ai}, ${ci}`).addClass(oi), n.parents(si).prev(li).children(ai).addClass(oi)), p(this._scrollElement).trigger(ni.ACTIVATE, { relatedTarget: e }); }, t._clear = function () { [].slice.call(document.querySelectorAll(this._selector)).filter((t) => t.classList.contains(oi)).forEach((t) => t.classList.remove(oi)); }, n._jQueryInterface = function (e) { return this.each(function () { let t = p(this).data(Jn); if (t || (t = new n(this, typeof e === 'object' && e), p(this).data(Jn, t)), typeof e === 'string') { if (typeof t[e] === 'undefined') throw new TypeError(`No method named "${e}"`); t[e](); } }); }, s(n, null, [{ key: 'VERSION', get() { return '4.2.1'; } }, { key: 'Default', get() { return ti; } }]), n;
  }()); p(window).on(ni.LOAD_DATA_API, () => { for (let t = [].slice.call(document.querySelectorAll(ri)), e = t.length; e--;) { const n = p(t[e]); mi._jQueryInterface.call(n, n.data()); } }), p.fn[Gn] = mi._jQueryInterface, p.fn[Gn].Constructor = mi, p.fn[Gn].noConflict = function () { return p.fn[Gn] = $n, mi._jQueryInterface; }; const gi = 'bs.tab'; const _i = `.${gi}`; const vi = p.fn.tab; const yi = {
    HIDE: `hide${_i}`, HIDDEN: `hidden${_i}`, SHOW: `show${_i}`, SHOWN: `shown${_i}`, CLICK_DATA_API: `click${_i}.data-api`,
  }; const Ei = 'dropdown-menu'; const bi = 'active'; const wi = 'disabled'; const Ti = 'fade'; const Ci = 'show'; const Si = '.dropdown'; const Di = '.nav, .list-group'; const Ii = '.active'; const Ai = '> li > .active'; const Oi = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]'; const Ni = '.dropdown-toggle'; const ki = '> .dropdown-menu .active'; const Li = (function () { function i(t) { this._element = t; } const t = i.prototype; return t.show = function () { const n = this; if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && p(this._element).hasClass(bi) || p(this._element).hasClass(wi))) { let t; let i; const e = p(this._element).closest(Di)[0]; const o = m.getSelectorFromElement(this._element); if (e) { const r = e.nodeName === 'UL' || e.nodeName === 'OL' ? Ai : Ii; i = (i = p.makeArray(p(e).find(r)))[i.length - 1]; } const s = p.Event(yi.HIDE, { relatedTarget: this._element }); const a = p.Event(yi.SHOW, { relatedTarget: i }); if (i && p(i).trigger(s), p(this._element).trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) { o && (t = document.querySelector(o)), this._activate(this._element, e); const l = function () { const t = p.Event(yi.HIDDEN, { relatedTarget: n._element }); const e = p.Event(yi.SHOWN, { relatedTarget: i }); p(i).trigger(t), p(n._element).trigger(e); }; t ? this._activate(t, t.parentNode, l) : l(); } } }, t.dispose = function () { p.removeData(this._element, gi), this._element = null; }, t._activate = function (t, e, n) { const i = this; const o = (!e || e.nodeName !== 'UL' && e.nodeName !== 'OL' ? p(e).children(Ii) : p(e).find(Ai))[0]; const r = n && o && p(o).hasClass(Ti); const s = function () { return i._transitionComplete(t, o, n); }; if (o && r) { const a = m.getTransitionDurationFromElement(o); p(o).removeClass(Ci).one(m.TRANSITION_END, s).emulateTransitionEnd(a); } else s(); }, t._transitionComplete = function (t, e, n) { if (e) { p(e).removeClass(bi); const i = p(e.parentNode).find(ki)[0]; i && p(i).removeClass(bi), e.getAttribute('role') === 'tab' && e.setAttribute('aria-selected', !1); } if (p(t).addClass(bi), t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !0), m.reflow(t), p(t).addClass(Ci), t.parentNode && p(t.parentNode).hasClass(Ei)) { const o = p(t).closest(Si)[0]; if (o) { const r = [].slice.call(o.querySelectorAll(Ni)); p(r).addClass(bi); }t.setAttribute('aria-expanded', !0); }n && n(); }, i._jQueryInterface = function (n) { return this.each(function () { const t = p(this); let e = t.data(gi); if (e || (e = new i(this), t.data(gi, e)), typeof n === 'string') { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n](); } }); }, s(i, null, [{ key: 'VERSION', get() { return '4.2.1'; } }]), i; }()); p(document).on(yi.CLICK_DATA_API, Oi, function (t) { t.preventDefault(), Li._jQueryInterface.call(p(this), 'show'); }), p.fn.tab = Li._jQueryInterface, p.fn.tab.Constructor = Li, p.fn.tab.noConflict = function () { return p.fn.tab = vi, Li._jQueryInterface; }; const Pi = 'toast'; const xi = 'bs.toast'; const Hi = `.${xi}`; const ji = p.fn[Pi]; const Ri = {
    CLICK_DISMISS: `click.dismiss${Hi}`, HIDE: `hide${Hi}`, HIDDEN: `hidden${Hi}`, SHOW: `show${Hi}`, SHOWN: `shown${Hi}`,
  }; const Fi = 'fade'; const Mi = 'hide'; const Wi = 'show'; const Ui = 'showing'; const Bi = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const qi = { animation: !0, autohide: !0, delay: 500 }; const Ki = '[data-dismiss="toast"]'; const Qi = (function () { function i(t, e) { this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners(); } const t = i.prototype; return t.show = function () { const t = this; p(this._element).trigger(Ri.SHOW), this._config.animation && this._element.classList.add(Fi); const e = function () { t._element.classList.remove(Ui), t._element.classList.add(Wi), p(t._element).trigger(Ri.SHOWN), t._config.autohide && t.hide(); }; if (this._element.classList.remove(Mi), this._element.classList.add(Ui), this._config.animation) { const n = m.getTransitionDurationFromElement(this._element); p(this._element).one(m.TRANSITION_END, e).emulateTransitionEnd(n); } else e(); }, t.hide = function (t) { const e = this; this._element.classList.contains(Wi) && (p(this._element).trigger(Ri.HIDE), t ? this._close() : this._timeout = setTimeout(() => { e._close(); }, this._config.delay)); }, t.dispose = function () { clearTimeout(this._timeout), this._timeout = null, this._element.classList.contains(Wi) && this._element.classList.remove(Wi), p(this._element).off(Ri.CLICK_DISMISS), p.removeData(this._element, xi), this._element = null, this._config = null; }, t._getConfig = function (t) { return t = l({}, qi, p(this._element).data(), typeof t === 'object' && t ? t : {}), m.typeCheckConfig(Pi, t, this.constructor.DefaultType), t; }, t._setListeners = function () { const t = this; p(this._element).on(Ri.CLICK_DISMISS, Ki, () => t.hide(!0)); }, t._close = function () { const t = this; const e = function () { t._element.classList.add(Mi), p(t._element).trigger(Ri.HIDDEN); }; if (this._element.classList.remove(Wi), this._config.animation) { const n = m.getTransitionDurationFromElement(this._element); p(this._element).one(m.TRANSITION_END, e).emulateTransitionEnd(n); } else e(); }, i._jQueryInterface = function (n) { return this.each(function () { const t = p(this); let e = t.data(xi); if (e || (e = new i(this, typeof n === 'object' && n), t.data(xi, e)), typeof n === 'string') { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n](this); } }); }, s(i, null, [{ key: 'VERSION', get() { return '4.2.1'; } }, { key: 'DefaultType', get() { return Bi; } }]), i; }()); p.fn[Pi] = Qi._jQueryInterface, p.fn[Pi].Constructor = Qi, p.fn[Pi].noConflict = function () { return p.fn[Pi] = ji, Qi._jQueryInterface; }, (function () { if (typeof p === 'undefined') throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript."); const t = p.fn.jquery.split(' ')[0].split('.'); if (t[0] < 2 && t[1] < 9 || t[0] === 1 && t[1] === 9 && t[2] < 1 || t[0] >= 4) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0"); }()), t.Util = m, t.Alert = g, t.Button = k, t.Carousel = at, t.Collapse = Tt, t.Dropdown = ze, t.Modal = pn, t.Popover = zn, t.Scrollspy = mi, t.Tab = Li, t.Toast = Qi, t.Tooltip = Hn, Object.defineProperty(t, '__esModule', { value: !0 });
}));
// # sourceMappingURL=bootstrap.bundle.min.js.map
